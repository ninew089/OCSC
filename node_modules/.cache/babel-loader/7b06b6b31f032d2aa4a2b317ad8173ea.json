{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar line_1 = require(\"./line\");\n\nvar util_1 = require(\"./util\");\n\nfunction analyzePoints(points) {\n  // 计算每段的长度和总的长度\n  var totalLength = 0;\n  var segments = [];\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var from = points[i];\n    var to = points[i + 1];\n    var length_1 = util_1.distance(from[0], from[1], to[0], to[1]);\n    var seg = {\n      from: from,\n      to: to,\n      length: length_1\n    };\n    segments.push(seg);\n    totalLength += length_1;\n  }\n\n  return {\n    segments: segments,\n    totalLength: totalLength\n  };\n}\n\nfunction lengthOfSegment(points) {\n  if (points.length < 2) {\n    return 0;\n  }\n\n  var totalLength = 0;\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var from = points[i];\n    var to = points[i + 1];\n    totalLength += util_1.distance(from[0], from[1], to[0], to[1]);\n  }\n\n  return totalLength;\n}\n\nexports.lengthOfSegment = lengthOfSegment;\n/**\n * 按照比例在数据片段中获取点\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n * @return {object} 点的坐标\n */\n\nfunction pointAtSegments(points, t) {\n  // 边界判断\n  if (t > 1 || t < 0 || points.length < 2) {\n    return null;\n  }\n\n  var _a = analyzePoints(points),\n      segments = _a.segments,\n      totalLength = _a.totalLength; // 多个点有可能重合\n\n\n  if (totalLength === 0) {\n    return {\n      x: points[0][0],\n      y: points[0][1]\n    };\n  } // 计算比例\n\n\n  var startRatio = 0;\n  var point = null;\n\n  for (var i = 0; i < segments.length; i++) {\n    var seg = segments[i];\n    var from = seg.from,\n        to = seg.to;\n    var currentRatio = seg.length / totalLength;\n\n    if (t >= startRatio && t <= startRatio + currentRatio) {\n      var localRatio = (t - startRatio) / currentRatio;\n      point = line_1.default.pointAt(from[0], from[1], to[0], to[1], localRatio);\n      break;\n    }\n\n    startRatio += currentRatio;\n  }\n\n  return point;\n}\n\nexports.pointAtSegments = pointAtSegments;\n/**\n * 按照比例在数据片段中获取切线的角度\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n */\n\nfunction angleAtSegments(points, t) {\n  // 边界判断\n  if (t > 1 || t < 0 || points.length < 2) {\n    return 0;\n  }\n\n  var _a = analyzePoints(points),\n      segments = _a.segments,\n      totalLength = _a.totalLength; // 计算比例\n\n\n  var startRatio = 0;\n  var angle = 0;\n\n  for (var i = 0; i < segments.length; i++) {\n    var seg = segments[i];\n    var from = seg.from,\n        to = seg.to;\n    var currentRatio = seg.length / totalLength;\n\n    if (t >= startRatio && t <= startRatio + currentRatio) {\n      angle = Math.atan2(to[1] - from[1], to[0] - from[0]);\n      break;\n    }\n\n    startRatio += currentRatio;\n  }\n\n  return angle;\n}\n\nexports.angleAtSegments = angleAtSegments;\n\nfunction distanceAtSegment(points, x, y) {\n  var minDistance = Infinity;\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var point = points[i];\n    var nextPoint = points[i + 1];\n    var distance_1 = line_1.default.pointDistance(point[0], point[1], nextPoint[0], nextPoint[1], x, y);\n\n    if (distance_1 < minDistance) {\n      minDistance = distance_1;\n    }\n  }\n\n  return minDistance;\n}\n\nexports.distanceAtSegment = distanceAtSegment;","map":{"version":3,"sources":["../src/segments.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar line_1 = require(\"./line\");\nvar util_1 = require(\"./util\");\nfunction analyzePoints(points) {\n    // 计算每段的长度和总的长度\n    var totalLength = 0;\n    var segments = [];\n    for (var i = 0; i < points.length - 1; i++) {\n        var from = points[i];\n        var to = points[i + 1];\n        var length_1 = util_1.distance(from[0], from[1], to[0], to[1]);\n        var seg = {\n            from: from,\n            to: to,\n            length: length_1,\n        };\n        segments.push(seg);\n        totalLength += length_1;\n    }\n    return { segments: segments, totalLength: totalLength };\n}\nfunction lengthOfSegment(points) {\n    if (points.length < 2) {\n        return 0;\n    }\n    var totalLength = 0;\n    for (var i = 0; i < points.length - 1; i++) {\n        var from = points[i];\n        var to = points[i + 1];\n        totalLength += util_1.distance(from[0], from[1], to[0], to[1]);\n    }\n    return totalLength;\n}\nexports.lengthOfSegment = lengthOfSegment;\n/**\n * 按照比例在数据片段中获取点\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n * @return {object} 点的坐标\n */\nfunction pointAtSegments(points, t) {\n    // 边界判断\n    if (t > 1 || t < 0 || points.length < 2) {\n        return null;\n    }\n    var _a = analyzePoints(points), segments = _a.segments, totalLength = _a.totalLength;\n    // 多个点有可能重合\n    if (totalLength === 0) {\n        return {\n            x: points[0][0],\n            y: points[0][1],\n        };\n    }\n    // 计算比例\n    var startRatio = 0;\n    var point = null;\n    for (var i = 0; i < segments.length; i++) {\n        var seg = segments[i];\n        var from = seg.from, to = seg.to;\n        var currentRatio = seg.length / totalLength;\n        if (t >= startRatio && t <= startRatio + currentRatio) {\n            var localRatio = (t - startRatio) / currentRatio;\n            point = line_1.default.pointAt(from[0], from[1], to[0], to[1], localRatio);\n            break;\n        }\n        startRatio += currentRatio;\n    }\n    return point;\n}\nexports.pointAtSegments = pointAtSegments;\n/**\n * 按照比例在数据片段中获取切线的角度\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n */\nfunction angleAtSegments(points, t) {\n    // 边界判断\n    if (t > 1 || t < 0 || points.length < 2) {\n        return 0;\n    }\n    var _a = analyzePoints(points), segments = _a.segments, totalLength = _a.totalLength;\n    // 计算比例\n    var startRatio = 0;\n    var angle = 0;\n    for (var i = 0; i < segments.length; i++) {\n        var seg = segments[i];\n        var from = seg.from, to = seg.to;\n        var currentRatio = seg.length / totalLength;\n        if (t >= startRatio && t <= startRatio + currentRatio) {\n            angle = Math.atan2(to[1] - from[1], to[0] - from[0]);\n            break;\n        }\n        startRatio += currentRatio;\n    }\n    return angle;\n}\nexports.angleAtSegments = angleAtSegments;\nfunction distanceAtSegment(points, x, y) {\n    var minDistance = Infinity;\n    for (var i = 0; i < points.length - 1; i++) {\n        var point = points[i];\n        var nextPoint = points[i + 1];\n        var distance_1 = line_1.default.pointDistance(point[0], point[1], nextPoint[0], nextPoint[1], x, y);\n        if (distance_1 < minDistance) {\n            minDistance = distance_1;\n        }\n    }\n    return minDistance;\n}\nexports.distanceAtSegment = distanceAtSegment;\n//# sourceMappingURL=segments.js.map"]},"metadata":{},"sourceType":"script"}