{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { deepMix, each, get, isArray, isFunction, isNil, isUndefined } from '@antv/util';\nimport { FIELD_ORIGIN } from '../../constant';\nimport { getDefaultAnimateCfg } from '../../animate';\nimport { getPolygonCentroid } from '../../util/graphics';\nimport Labels from '../../component/labels';\n\nfunction avg(arr) {\n  var sum = 0;\n  each(arr, function (value) {\n    sum += value;\n  });\n  return sum / arr.length;\n}\n/**\n * Geometry Label 基类，用于生成 Geometry 下所有 label 的配置项信息\n */\n\n\nvar GeometryLabel =\n/** @class */\nfunction () {\n  function GeometryLabel(geometry) {\n    this.geometry = geometry;\n  }\n\n  GeometryLabel.prototype.getLabelItems = function (mapppingArray) {\n    var _this = this;\n\n    var items = [];\n    var labelCfgs = this.getLabelCfgs(mapppingArray); // 获取 label 相关的 x，y 的值，获取具体的 x, y，防止存在数组\n\n    each(mapppingArray, function (mappingData, index) {\n      var labelCfg = labelCfgs[index];\n\n      if (!labelCfg || isNil(mappingData.x) || isNil(mappingData.y)) {\n        items.push(null);\n        return;\n      }\n\n      var labelContent = !isArray(labelCfg.content) ? [labelCfg.content] : labelCfg.content;\n      labelCfg.content = labelContent;\n      var total = labelContent.length;\n      each(labelContent, function (content, subIndex) {\n        if (isNil(content) || content === '') {\n          items.push(null);\n          return;\n        }\n\n        var item = __assign(__assign({}, labelCfg), _this.getLabelPoint(labelCfg, mappingData, subIndex));\n\n        if (!item.textAlign) {\n          item.textAlign = _this.getLabelAlign(item, subIndex, total);\n        }\n\n        if (item.offset <= 0) {\n          item.labelLine = null;\n        }\n\n        items.push(item);\n      });\n    });\n    return items;\n  };\n\n  GeometryLabel.prototype.render = function (mapppingArray, isUpdate) {\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n\n    var labelItems = this.getLabelItems(mapppingArray);\n    var labelsRenderer = this.getLabelsRenderer();\n    var shapes = this.getGeometryShapes(); // 渲染文本\n\n    labelsRenderer.render(labelItems, shapes, isUpdate);\n  };\n\n  GeometryLabel.prototype.clear = function () {\n    var labelsRenderer = this.labelsRenderer;\n\n    if (labelsRenderer) {\n      labelsRenderer.clear();\n    }\n  };\n\n  GeometryLabel.prototype.destroy = function () {\n    var labelsRenderer = this.labelsRenderer;\n\n    if (labelsRenderer) {\n      labelsRenderer.destroy();\n    }\n\n    this.labelsRenderer = null;\n  }; // geometry 更新之后，对应的 Coordinate 也会更新，为了获取到最新鲜的 Coordinate，故使用方法获取\n\n\n  GeometryLabel.prototype.getCoordinate = function () {\n    return this.geometry.coordinate;\n  };\n  /**\n   * 获取 label 的默认配置\n   */\n\n\n  GeometryLabel.prototype.getDefaultLabelCfg = function () {\n    return get(this.geometry.theme, 'labels', {});\n  };\n  /**\n   * 设置 label 位置\n   * @param labelPointCfg\n   * @param mappingData\n   * @param index\n   * @param position\n   */\n\n\n  GeometryLabel.prototype.setLabelPosition = function (labelPointCfg, mappingData, index, position) {};\n  /**\n   * 获取文本默认偏移量\n   * @param offset\n   * @returns\n   */\n\n\n  GeometryLabel.prototype.getDefaultOffset = function (offset) {\n    var coordinate = this.getCoordinate();\n    var vector = this.getOffsetVector(offset);\n    return coordinate.isTransposed ? vector[0] : vector[1];\n  };\n  /**\n   * 获取每个 label 的偏移量\n   * @param labelCfg\n   * @param index\n   * @param total\n   * @returns\n   */\n\n\n  GeometryLabel.prototype.getLabelOffset = function (labelCfg, index, total) {\n    var offset = this.getDefaultOffset(labelCfg.offset);\n    var coordinate = this.getCoordinate();\n    var transposed = coordinate.isTransposed;\n    var dim = transposed ? 'x' : 'y';\n    var factor = transposed ? 1 : -1; // y 方向上越大，像素的坐标越小，所以transposed时将系数变成\n\n    var offsetPoint = {\n      x: 0,\n      y: 0\n    };\n\n    if (index > 0 || total === 1) {\n      // 判断是否小于0\n      offsetPoint[dim] = offset * factor;\n    } else {\n      offsetPoint[dim] = offset * factor * -1;\n    }\n\n    return offsetPoint;\n  };\n  /**\n   * 获取每个 label 的位置\n   * @param labelCfg\n   * @param mappingData\n   * @param index\n   * @returns label point\n   */\n\n\n  GeometryLabel.prototype.getLabelPoint = function (labelCfg, mappingData, index) {\n    var coordinate = this.getCoordinate();\n    var total = labelCfg.content.length;\n\n    function getDimValue(value, idx) {\n      var v = value;\n\n      if (isArray(v)) {\n        if (labelCfg.content.length === 1) {\n          // 如果仅一个 label，多个 y, 取最后一个 y\n          if (v.length <= 2) {\n            v = v[value.length - 1];\n          } else {\n            v = avg(v);\n          }\n        } else {\n          v = v[idx];\n        }\n      }\n\n      return v;\n    }\n\n    var label = {\n      content: labelCfg.content[index],\n      x: 0,\n      y: 0,\n      start: {\n        x: 0,\n        y: 0\n      },\n      color: '#fff'\n    }; // 多边形场景，多用于地图\n\n    if (mappingData && this.geometry.type === 'polygon') {\n      var centroid = getPolygonCentroid(mappingData.x, mappingData.y);\n      label.x = centroid[0];\n      label.y = centroid[1];\n    } else {\n      label.x = getDimValue(mappingData.x, index);\n      label.y = getDimValue(mappingData.y, index);\n    } // 处理漏斗图文本位置\n\n\n    var shape = isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;\n\n    if (shape === 'funnel' || shape === 'pyramid') {\n      var nextPoints = get(mappingData, 'nextPoints');\n      var points = get(mappingData, 'points');\n\n      if (nextPoints) {\n        // 非漏斗图底部\n        var point1 = coordinate.convert(points[1]);\n        var point2 = coordinate.convert(nextPoints[1]);\n        label.x = (point1.x + point2.x) / 2;\n        label.y = (point1.y + point2.y) / 2;\n      } else if (shape === 'pyramid') {\n        var point1 = coordinate.convert(points[1]);\n        var point2 = coordinate.convert(points[2]);\n        label.x = (point1.x + point2.x) / 2;\n        label.y = (point1.y + point2.y) / 2;\n      }\n    }\n\n    if (labelCfg.position) {\n      // 如果 label 支持 position 属性\n      this.setLabelPosition(label, mappingData, index, labelCfg.position);\n    }\n\n    var offsetPoint = this.getLabelOffset(labelCfg, index, total);\n    label.start = {\n      x: label.x,\n      y: label.y\n    };\n    label.x += offsetPoint.x;\n    label.y += offsetPoint.y;\n    label.color = mappingData.color;\n    return label;\n  };\n  /**\n   * 获取文本的对齐方式\n   * @param item\n   * @param index\n   * @param total\n   * @returns\n   */\n\n\n  GeometryLabel.prototype.getLabelAlign = function (item, index, total) {\n    var align = 'center';\n    var coordinate = this.getCoordinate();\n\n    if (coordinate.isTransposed) {\n      var offset = this.getDefaultOffset(item.offset);\n\n      if (offset < 0) {\n        align = 'right';\n      } else if (offset === 0) {\n        align = 'center';\n      } else {\n        align = 'left';\n      }\n\n      if (total > 1 && index === 0) {\n        if (align === 'right') {\n          align = 'left';\n        } else if (align === 'left') {\n          align = 'right';\n        }\n      }\n    }\n\n    return align;\n  };\n  /**\n   * 获取每一个 label 的唯一 id\n   * @param mappingData label 对应的图形的绘制数据\n   */\n\n\n  GeometryLabel.prototype.getLabelId = function (mappingData) {\n    var geometry = this.geometry;\n    var type = geometry.type;\n    var xScale = geometry.getXScale();\n    var yScale = geometry.getYScale();\n    var origin = mappingData[FIELD_ORIGIN]; // 原始数据\n\n    var labelId = geometry.getElementId(mappingData);\n\n    if (type === 'line' || type === 'area') {\n      // 折线图以及区域图，一条线会对应一组数据，即多个 labels，为了区分这些 labels，需要在 line id 的前提下加上 x 字段值\n      labelId += \" \" + origin[xScale.field];\n    } else if (type === 'path') {\n      // path 路径图，无序，有可能存在相同 x 不同 y 的情况，需要通过 x y 来确定唯一 id\n      labelId += \" \" + origin[xScale.field] + \"-\" + origin[yScale.field];\n    }\n\n    return labelId;\n  }; // 获取 labels 组件\n\n\n  GeometryLabel.prototype.getLabelsRenderer = function () {\n    var _a = this.geometry,\n        labelsContainer = _a.labelsContainer,\n        labelOption = _a.labelOption,\n        canvasRegion = _a.canvasRegion,\n        animateOption = _a.animateOption;\n    var coordinate = this.geometry.coordinate;\n    var labelsRenderer = this.labelsRenderer;\n\n    if (!labelsRenderer) {\n      labelsRenderer = new Labels({\n        container: labelsContainer,\n        layout: get(labelOption, ['cfg', 'layout'], {\n          type: this.defaultLayout\n        })\n      });\n      this.labelsRenderer = labelsRenderer;\n    }\n\n    labelsRenderer.region = canvasRegion; // 设置动画配置，如果 geometry 的动画关闭了，那么 label 的动画也会关闭\n\n    labelsRenderer.animate = animateOption ? getDefaultAnimateCfg('label', coordinate) : false;\n    return labelsRenderer;\n  };\n\n  GeometryLabel.prototype.getLabelCfgs = function (mapppingArray) {\n    var _this = this;\n\n    var geometry = this.geometry;\n    var defaultLabelCfg = this.getDefaultLabelCfg();\n    var type = geometry.type,\n        theme = geometry.theme,\n        labelOption = geometry.labelOption,\n        scales = geometry.scales,\n        coordinate = geometry.coordinate;\n    var _a = labelOption,\n        fields = _a.fields,\n        callback = _a.callback,\n        cfg = _a.cfg;\n    var labelScales = fields.map(function (field) {\n      return scales[field];\n    });\n    var labelCfgs = [];\n    each(mapppingArray, function (mappingData, index) {\n      var origin = mappingData[FIELD_ORIGIN]; // 原始数据\n\n      var originText = _this.getLabelText(origin, labelScales);\n\n      var callbackCfg;\n\n      if (callback) {\n        // 当同时配置了 callback 和 cfg 时，以 callback 为准\n        var originValues = fields.map(function (field) {\n          return origin[field];\n        });\n        callbackCfg = callback.apply(void 0, originValues);\n\n        if (isNil(callbackCfg)) {\n          labelCfgs.push(null);\n          return;\n        }\n      }\n\n      var labelCfg = __assign(__assign({\n        id: _this.getLabelId(mappingData),\n        data: origin,\n        // 存储原始数据\n        mappingData: mappingData,\n        coordinate: coordinate\n      }, cfg), callbackCfg);\n\n      var content = labelCfg.content;\n\n      if (isFunction(content)) {\n        labelCfg.content = content(origin, mappingData, index);\n      } else if (isUndefined(content)) {\n        // 用户未配置 content，则默认为映射的第一个字段的值\n        labelCfg.content = originText[0];\n      }\n\n      if (isFunction(labelCfg.position)) {\n        labelCfg.position = labelCfg.position(origin, mappingData, index);\n      }\n\n      if (type === 'polygon' || labelCfg.offset < 0 && !['line', 'point', 'path'].includes(type)) {\n        // polygon 或者 offset 小于 0 时，文本展示在图形内部，将其颜色设置为 白色\n        labelCfg = deepMix({}, defaultLabelCfg, theme.innerLabels, labelCfg);\n      } else {\n        labelCfg = deepMix({}, defaultLabelCfg, theme.labels, labelCfg);\n      }\n\n      labelCfgs.push(labelCfg);\n    });\n    return labelCfgs;\n  };\n\n  GeometryLabel.prototype.getLabelText = function (origin, scales) {\n    var labelTexts = [];\n    each(scales, function (scale) {\n      var value = origin[scale.field];\n\n      if (isArray(value)) {\n        value = value.map(function (subVal) {\n          return scale.getText(subVal);\n        });\n      } else {\n        value = scale.getText(value);\n      }\n\n      if (isNil(value) || value === '') {\n        labelTexts.push(null);\n      } else {\n        labelTexts.push(value);\n      }\n    });\n    return labelTexts;\n  };\n\n  GeometryLabel.prototype.getOffsetVector = function (offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    var coordinate = this.getCoordinate(); // 如果 x,y 翻转，则偏移 x，否则偏移 y\n\n    return coordinate.isTransposed ? coordinate.applyMatrix(offset, 0) : coordinate.applyMatrix(0, offset);\n  };\n\n  GeometryLabel.prototype.getGeometryShapes = function () {\n    var geometry = this.geometry;\n    var shapes = {};\n    each(geometry.elementsMap, function (element, id) {\n      shapes[id] = element.shape;\n    }); // 因为有可能 shape 还在进行动画，导致 shape.getBBox() 获取到的值不是最终态，所以需要从 offscreenGroup 获取\n\n    each(geometry.getOffscreenGroup().getChildren(), function (child) {\n      var id = geometry.getElementId(child.get('origin').mappingData);\n      shapes[id] = child;\n    });\n    return shapes;\n  };\n\n  return GeometryLabel;\n}();\n\nexport default GeometryLabel;","map":{"version":3,"sources":["../../../src/geometry/label/base.ts"],"names":[],"mappings":"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","sourcesContent":["import { deepMix, each, get, isArray, isFunction, isNil, isUndefined } from '@antv/util';\n\nimport { FIELD_ORIGIN } from '../../constant';\nimport { Scale } from '../../dependents';\nimport { Datum, LabelOption, MappingDatum, Point } from '../../interface';\nimport { LabelCfg, LabelItem, LabelPointCfg, TextAlign } from './interface';\n\nimport { getDefaultAnimateCfg } from '../../animate';\nimport { getPolygonCentroid } from '../../util/graphics';\n\nimport Labels from '../../component/labels';\nimport Geometry from '../base';\nimport Element from '../element';\n\nexport type GeometryLabelConstructor = new (cfg: any) => GeometryLabel;\n\nfunction avg(arr: number[]) {\n  let sum = 0;\n  each(arr, (value: number) => {\n    sum += value;\n  });\n  return sum / arr.length;\n}\n\n/**\n * Geometry Label 基类，用于生成 Geometry 下所有 label 的配置项信息\n */\nexport default class GeometryLabel {\n  /** geometry 实例 */\n  public readonly geometry: Geometry;\n  public labelsRenderer: Labels;\n  /** 默认的布局 */\n  public defaultLayout: string;\n\n  constructor(geometry: Geometry) {\n    this.geometry = geometry;\n  }\n\n  public getLabelItems(mapppingArray: MappingDatum[]): LabelItem[] {\n    const items = [];\n    const labelCfgs = this.getLabelCfgs(mapppingArray);\n    // 获取 label 相关的 x，y 的值，获取具体的 x, y，防止存在数组\n    each(mapppingArray, (mappingData: MappingDatum, index: number) => {\n      const labelCfg = labelCfgs[index];\n      if (!labelCfg || isNil(mappingData.x) || isNil(mappingData.y)) {\n        items.push(null);\n        return;\n      }\n\n      const labelContent = !isArray(labelCfg.content) ? [labelCfg.content] : labelCfg.content;\n      labelCfg.content = labelContent;\n      const total = labelContent.length;\n      each(labelContent, (content, subIndex) => {\n        if (isNil(content) || content === '') {\n          items.push(null);\n          return;\n        }\n\n        const item = {\n          ...labelCfg,\n          ...this.getLabelPoint(labelCfg, mappingData, subIndex),\n        };\n        if (!item.textAlign) {\n          item.textAlign = this.getLabelAlign(item, subIndex, total);\n        }\n\n        if (item.offset <= 0) {\n          item.labelLine = null;\n        }\n\n        items.push(item);\n      });\n    });\n    return items;\n  }\n\n  public render(mapppingArray: MappingDatum[], isUpdate: boolean = false) {\n    const labelItems = this.getLabelItems(mapppingArray);\n\n    const labelsRenderer = this.getLabelsRenderer();\n    const shapes = this.getGeometryShapes();\n    // 渲染文本\n    labelsRenderer.render(labelItems, shapes, isUpdate);\n  }\n\n  public clear() {\n    const labelsRenderer = this.labelsRenderer;\n    if (labelsRenderer) {\n      labelsRenderer.clear();\n    }\n  }\n\n  public destroy() {\n    const labelsRenderer = this.labelsRenderer;\n    if (labelsRenderer) {\n      labelsRenderer.destroy();\n    }\n    this.labelsRenderer = null;\n  }\n\n  // geometry 更新之后，对应的 Coordinate 也会更新，为了获取到最新鲜的 Coordinate，故使用方法获取\n  public getCoordinate() {\n    return this.geometry.coordinate;\n  }\n\n  /**\n   * 获取 label 的默认配置\n   */\n  protected getDefaultLabelCfg() {\n    return get(this.geometry.theme, 'labels', {});\n  }\n\n  /**\n   * 设置 label 位置\n   * @param labelPointCfg\n   * @param mappingData\n   * @param index\n   * @param position\n   */\n  protected setLabelPosition(\n    labelPointCfg: LabelPointCfg,\n    mappingData: MappingDatum,\n    index: number,\n    position: string\n  ) {}\n\n  /**\n   * 获取文本默认偏移量\n   * @param offset\n   * @returns\n   */\n  protected getDefaultOffset(offset: number) {\n    const coordinate = this.getCoordinate();\n    const vector = this.getOffsetVector(offset);\n    return coordinate.isTransposed ? vector[0] : vector[1];\n  }\n\n  /**\n   * 获取每个 label 的偏移量\n   * @param labelCfg\n   * @param index\n   * @param total\n   * @returns\n   */\n  protected getLabelOffset(labelCfg: LabelCfg, index: number, total: number) {\n    const offset = this.getDefaultOffset(labelCfg.offset);\n    const coordinate = this.getCoordinate();\n    const transposed = coordinate.isTransposed;\n    const dim = transposed ? 'x' : 'y';\n    const factor = transposed ? 1 : -1; // y 方向上越大，像素的坐标越小，所以transposed时将系数变成\n    const offsetPoint = {\n      x: 0,\n      y: 0,\n    };\n    if (index > 0 || total === 1) {\n      // 判断是否小于0\n      offsetPoint[dim] = offset * factor;\n    } else {\n      offsetPoint[dim] = offset * factor * -1;\n    }\n    return offsetPoint;\n  }\n\n  /**\n   * 获取每个 label 的位置\n   * @param labelCfg\n   * @param mappingData\n   * @param index\n   * @returns label point\n   */\n  protected getLabelPoint(labelCfg: LabelCfg, mappingData: MappingDatum, index: number): LabelPointCfg {\n    const coordinate = this.getCoordinate();\n    const total = labelCfg.content.length;\n\n    function getDimValue(value, idx) {\n      let v = value;\n      if (isArray(v)) {\n        if (labelCfg.content.length === 1) {\n          // 如果仅一个 label，多个 y, 取最后一个 y\n          if (v.length <= 2) {\n            v = v[value.length - 1];\n          } else {\n            v = avg(v);\n          }\n        } else {\n          v = v[idx];\n        }\n      }\n      return v;\n    }\n\n    const label = {\n      content: labelCfg.content[index],\n      x: 0,\n      y: 0,\n      start: { x: 0, y: 0 },\n      color: '#fff',\n    };\n    // 多边形场景，多用于地图\n    if (mappingData && this.geometry.type === 'polygon') {\n      const centroid = getPolygonCentroid(mappingData.x, mappingData.y);\n      label.x = centroid[0];\n      label.y = centroid[1];\n    } else {\n      label.x = getDimValue(mappingData.x, index);\n      label.y = getDimValue(mappingData.y, index);\n    }\n\n    // 处理漏斗图文本位置\n    const shape = isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;\n    if (shape === 'funnel' || shape === 'pyramid') {\n      const nextPoints = get(mappingData, 'nextPoints');\n      const points = get(mappingData, 'points');\n      if (nextPoints) {\n        // 非漏斗图底部\n        const point1 = coordinate.convert(points[1] as Point);\n        const point2 = coordinate.convert(nextPoints[1] as Point);\n        label.x = (point1.x + point2.x) / 2;\n        label.y = (point1.y + point2.y) / 2;\n      } else if (shape === 'pyramid') {\n        const point1 = coordinate.convert(points[1] as Point);\n        const point2 = coordinate.convert(points[2] as Point);\n        label.x = (point1.x + point2.x) / 2;\n        label.y = (point1.y + point2.y) / 2;\n      }\n    }\n\n    if (labelCfg.position) {\n      // 如果 label 支持 position 属性\n      this.setLabelPosition(label, mappingData, index, labelCfg.position);\n    }\n    const offsetPoint = this.getLabelOffset(labelCfg, index, total);\n    label.start = { x: label.x, y: label.y };\n    label.x += offsetPoint.x;\n    label.y += offsetPoint.y;\n    label.color = mappingData.color;\n    return label;\n  }\n\n  /**\n   * 获取文本的对齐方式\n   * @param item\n   * @param index\n   * @param total\n   * @returns\n   */\n  protected getLabelAlign(item: LabelItem, index: number, total: number): TextAlign {\n    let align: TextAlign = 'center';\n    const coordinate = this.getCoordinate();\n    if (coordinate.isTransposed) {\n      const offset = this.getDefaultOffset(item.offset);\n      if (offset < 0) {\n        align = 'right';\n      } else if (offset === 0) {\n        align = 'center';\n      } else {\n        align = 'left';\n      }\n      if (total > 1 && index === 0) {\n        if (align === 'right') {\n          align = 'left';\n        } else if (align === 'left') {\n          align = 'right';\n        }\n      }\n    }\n    return align;\n  }\n\n  /**\n   * 获取每一个 label 的唯一 id\n   * @param mappingData label 对应的图形的绘制数据\n   */\n  protected getLabelId(mappingData: MappingDatum) {\n    const geometry = this.geometry;\n    const type = geometry.type;\n    const xScale = geometry.getXScale();\n    const yScale = geometry.getYScale();\n    const origin = mappingData[FIELD_ORIGIN]; // 原始数据\n\n    let labelId = geometry.getElementId(mappingData);\n    if (type === 'line' || type === 'area') {\n      // 折线图以及区域图，一条线会对应一组数据，即多个 labels，为了区分这些 labels，需要在 line id 的前提下加上 x 字段值\n      labelId += ` ${origin[xScale.field]}`;\n    } else if (type === 'path') {\n      // path 路径图，无序，有可能存在相同 x 不同 y 的情况，需要通过 x y 来确定唯一 id\n      labelId += ` ${origin[xScale.field]}-${origin[yScale.field]}`;\n    }\n\n    return labelId;\n  }\n\n  // 获取 labels 组件\n  private getLabelsRenderer() {\n    const { labelsContainer, labelOption, canvasRegion, animateOption } = this.geometry;\n    const coordinate = this.geometry.coordinate;\n\n    let labelsRenderer = this.labelsRenderer;\n    if (!labelsRenderer) {\n      labelsRenderer = new Labels({\n        container: labelsContainer,\n        layout: get(labelOption, ['cfg', 'layout'], {\n          type: this.defaultLayout,\n        }),\n      });\n      this.labelsRenderer = labelsRenderer;\n    }\n    labelsRenderer.region = canvasRegion;\n    // 设置动画配置，如果 geometry 的动画关闭了，那么 label 的动画也会关闭\n    labelsRenderer.animate = animateOption ? getDefaultAnimateCfg('label', coordinate) : false;\n\n    return labelsRenderer;\n  }\n\n  private getLabelCfgs(mapppingArray: MappingDatum[]): LabelCfg[] {\n    const geometry = this.geometry;\n    const defaultLabelCfg = this.getDefaultLabelCfg();\n    const { type, theme, labelOption, scales, coordinate } = geometry;\n    const { fields, callback, cfg } = labelOption as LabelOption;\n    const labelScales = fields.map((field: string) => {\n      return scales[field];\n    });\n\n    const labelCfgs: LabelCfg[] = [];\n    each(mapppingArray, (mappingData: MappingDatum, index: number) => {\n      const origin = mappingData[FIELD_ORIGIN]; // 原始数据\n      const originText = this.getLabelText(origin, labelScales);\n      let callbackCfg;\n      if (callback) {\n        // 当同时配置了 callback 和 cfg 时，以 callback 为准\n        const originValues = fields.map((field: string) => origin[field]);\n        callbackCfg = callback(...originValues);\n        if (isNil(callbackCfg)) {\n          labelCfgs.push(null);\n          return;\n        }\n      }\n\n      let labelCfg = {\n        id: this.getLabelId(mappingData), // 进行 ID 标记\n        data: origin, // 存储原始数据\n        mappingData, // 存储映射后的数据,\n        coordinate, // 坐标系\n        ...cfg,\n        ...callbackCfg,\n      };\n\n      const content = labelCfg.content;\n      if (isFunction(content)) {\n        labelCfg.content = content(origin, mappingData, index);\n      } else if (isUndefined(content)) {\n        // 用户未配置 content，则默认为映射的第一个字段的值\n        labelCfg.content = originText[0];\n      }\n\n      if (isFunction(labelCfg.position)) {\n        labelCfg.position = labelCfg.position(origin, mappingData, index);\n      }\n\n      if (type === 'polygon' || (labelCfg.offset < 0 && !['line', 'point', 'path'].includes(type))) {\n        // polygon 或者 offset 小于 0 时，文本展示在图形内部，将其颜色设置为 白色\n        labelCfg = deepMix({}, defaultLabelCfg, theme.innerLabels, labelCfg);\n      } else {\n        labelCfg = deepMix({}, defaultLabelCfg, theme.labels, labelCfg);\n      }\n\n      labelCfgs.push(labelCfg);\n    });\n\n    return labelCfgs;\n  }\n\n  private getLabelText(origin: Datum, scales: Scale[]) {\n    const labelTexts = [];\n    each(scales, (scale: Scale) => {\n      let value = origin[scale.field];\n      if (isArray(value)) {\n        value = value.map((subVal) => {\n          return scale.getText(subVal);\n        });\n      } else {\n        value = scale.getText(value);\n      }\n\n      if (isNil(value) || value === '') {\n        labelTexts.push(null);\n      } else {\n        labelTexts.push(value);\n      }\n    });\n    return labelTexts;\n  }\n\n  private getOffsetVector(offset = 0) {\n    const coordinate = this.getCoordinate();\n    // 如果 x,y 翻转，则偏移 x，否则偏移 y\n    return coordinate.isTransposed ? coordinate.applyMatrix(offset, 0) : coordinate.applyMatrix(0, offset);\n  }\n\n  private getGeometryShapes() {\n    const geometry = this.geometry;\n    const shapes = {};\n    each(geometry.elementsMap, (element: Element, id: string) => {\n      shapes[id] = element.shape;\n    });\n    // 因为有可能 shape 还在进行动画，导致 shape.getBBox() 获取到的值不是最终态，所以需要从 offscreenGroup 获取\n    each(geometry.getOffscreenGroup().getChildren(), (child) => {\n      const id = geometry.getElementId(child.get('origin').mappingData);\n      shapes[id] = child;\n    });\n\n    return shapes;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}